1. Looking at my code, I had consistent indentation, meaningful variable names (current_heap, payload_size), and modular functions (malloc, free, heap_dump, malloc_report). Some areas I can improve are adding more comments, especially before complex logic blocks, error handling with descriptive messages, and more consistent braces (whoops on assignment 5…I will fix that in the future). One thing I am proud of is how efficient my memory-recycling implementation was. One thing that could be improved was my extension for redzone detection, which did not work.

2. To test the functionality of my padding function, I created specific format strings and verified that the output matched the expected results. I used printf test cases and assert statements. This allowed me to control the input and predict the exact output. However, this doesn’t work well for malloc because we can’t see how memory is allocated, split, or coalesced without looking at data structures. The internal state is not clear, and memory addresses are unpredictable. One concrete example is, when testing printf, I could input "hi" with a format specifier "%5s" and expect the output to be " hi". The input and expected output are clear and verifiable. In malloc, if I allocate 100 bytes, free it, and then allocate another 100 bytes, I cannot confirm that the same memory block was reused without accessing the allocator's internal state. The returned pointer may or may not point to the same address due to fragmentation or other allocations.

3. One clear box test for recycling is the following: call malloc(100) to allocate 100 bytes, call free() on the allocated pointer, and call malloc(100) to check if the same memory block is reused. This verifies that the freed memory blocks are reused for new allocations of the same size. However, it does not tell us anything about edge cases like coalescing or behavior with different sizes. Additional test cases would include allocating different sizes, fragmenting blocks, and stress testing in random order.

4. (1) Incorrect alignment of allocated blocks occurs when malloc returns a pointer that is not properly aligned according to the required memory alignment (e.g., 8-byte alignment). The detection happens in the verify_block_address function after checking the alignment of the pointer returned by malloc using the expression ((uintptr_t)block->ptr) % ALIGNMENT != 0. If the result is non-zero, it means the pointer is not aligned to the required boundary (ALIGNMENT is defined as 8), and it reports "New block (%p) not aligned to %d bytes", block->ptr, ALIGNMENT.

(2) Blocks allocated outside the heap segment occur when malloc returns a pointer to a memory region that lies outside the heap managed by the allocator (before the heap start or beyond the heap end determined by sbrk(0)). The detection happens in the verify_block_address function by calculating the block’s end address using void *block_end = (char *)block->ptr + block->size. It then checks if the block starts before the heap start (sim->seg_start) or ends after the heap end (sim->seg_end) using if (block->ptr < sim->seg_start || block_end > sim->seg_end). If either condition is true, it reports: "New block (%p:%p) not within heap segment (%p:%p)", block->ptr, block_end, sim->seg_start, sim->seg_end.

(3) Overlapping memory blocks occur when malloc returns a pointer that overlaps with an already allocated block. The detection happens in the verify_block_address function, which iterates over all currently allocated blocks stored in sim->blocks. For each existing block, it checks if the new block overlaps with any allocated block by evaluating: if ((block->ptr >= other_start && block->ptr < other_end) || (block_end > other_start && block_end < other_end) || (block->ptr < other_start && block_end >= other_end)). If an overlap is detected, it reports: "New block (%p:%p) overlaps existing block (%p:%p)", block->ptr, block_end, other_start, other_end.

(4) Corrupted payload data in allocated blocks occurs when the contents of the block’s memory do not match the expected pattern, indicating issues like memory corruption. The detection happens in the verify_payloads function, which initializes each block’s payload with a specific pattern using: memset(block.ptr, block.size & 0xFF, block.size). The function then iterates through each allocated block and verifies its payload byte by byte to ensure it matches the expected value. If any mismatch is found, it reports: "Invalid payload data at offset %d of block at address %p", j, sim->blocks[i].ptr.

5. We prefer to use the heap_workflow function over more specific clear box tests like the one written in question 3 because it simulates realistic use (i.e., a more comprehensive workload over more malloc and free operations), it is implementation agnostic (it focuses only on external behavior), it detects more subtle bugs via randomized and extensive stress testing, is more efficient with testing, and has high test coverage. Box tests, on the other hand, are very specific and focus on a particular behavior, like memory recycling in one case. They are fragile to changes, and there may be oversights. One example is the following: Allocate 100 bytes, free it, and then allocate another 100 bytes to see if the same memory is reused. The limitation is that this test assumes knowledge of the internal allocation. However, consider the heap_workflow function: it randomly allocates and frees blocks of various sizes, tracking all pointers and sizes, and verifies that the allocator handles all operations correctly. Overall, this is more robust, efficient, and realistic.

